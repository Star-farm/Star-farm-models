/**
* Name: BasicExperiments
* This wizard creates a new experiment file. 
* Author: patricktaillandier
* Tags:  
*/ 

model STARFARM  

import "../Global.gaml"   

 
global{
	string current_indicator_family <- "Economy";
	int overlay_font_size <- 12;
	font overlay_font <- font("SansSerif", overlay_font_size, #bold);
	string show_season <- first(possible_practices.keys);
	int season_opacity <- 100;
	string time_range_type <- "All";
	map<string,unknown> options <- [];
	string scale <- "Total";
	
	// List of the key indicators to be monitored
	// the next list should be initialized using key_indicators from Practices.gaml, but presently there is a bug with Gama	
	list<string> chart_list <- ["Harvest","Profit","Water consumption","Fertilizer consumption","Adoption rate","Expenses details"];
	string current_chart <- first(chart_list);
	
	
	
	// ======================================================================
	// indicators
	// ======================================================================
	
	// computes the total biomass for a given type of crop and practice
	float get_total_biomass(Crop_practice p){
		return Crop where(each.the_farmer.practice = p) sum_of(each.B);
	}
	
	// computes the biomass per ha for a given type of crop and practice
	float get_biomass_per_ha(Crop_practice p){
		return p.practice_area = 0 ? 0 : get_total_biomass(p) / p.practice_area;
	}
	
	// computes the income per ha for a given type of crop and practice
	float get_income_per_ha(Crop_practice p){
		return p.practice_area = 0 ? 0 : p.day_income / p.practice_area;
	}
	
	// computes the biomass per ha for a given type of crop and practice
	float get_expenses_per_ha(Crop_practice p){
		return p.practice_area = 0 ? 0 : p.day_expenses / p.practice_area;
	}
	
	// detail the expenses per categories
	list<list<float>> get_expenses_by_category{
		list<list<float>> res <- [];
		loop i from: 0 to: length(expense_categories.keys)-1{
			list<float> vals;
			switch time_range_type{
				match "Last year" {
					vals <- practices.values collect (last(each.year_summary["Expense: "+expense_categories.keys[i]])
						/ (scale = "Total" ? 1 : max(0.001,each.practice_area))
					);
				}
				match "Last 3 years" {
					int last_index <- length(first(practices.values).year_summary["Expense: "+expense_categories.keys[i]]) - 1;
					vals <- practices.values collect (sum(copy_between(each.year_summary["Expense: "+expense_categories.keys[i]],last_index-2,last_index))
						/ (scale = "Total" ? 1 : max(0.001,each.practice_area)));
				}
				default {
					vals <- practices.values collect (sum(each.year_summary["Expense: "+expense_categories.keys[i]])
						/ (scale = "Total" ? 1 : max(0.001,each.practice_area)));
				}
			}	 
			res <+ vals;
		}
		return res;

	}
	
	
	// ======================================================================
	// auxiliary functions for charts
	// ======================================================================
	
	// compute the time range for charts, i.e. the number of days for which charts should be displayed
	int time_range(string s){
		int range <- max(1,cycle);
		switch s {
			match "Last year" {return min(365,range);}
			match "Last 3 years" {return min(1095,range);}
			default {return range;}
		}
	}
	
	// make x labels for season histograms
	list<string> update_x_labels(Crop_practice p){
		list<string> tmp;
		ask first(practices){
			tmp <- create_x_labels();
		}		 
		return tmp collect(each+p.id);
	}
	
	// used to keep only practices that are currently displayed
	list<Crop_practice> current_practices{
		return practices.values where (each.id = show_season);
	}
	

	// ======================================================================
	// functions to build yearly histograms
	// ======================================================================
	 
	// functions to build x labels for histograms
	list<string> add_ref_to_practice(string s){
		return practices collect (each.short_name+' '+s);
	}
	
	// generate the current histogram labels
	list<string> yearly_histo_labels{
		return first(practices).year_summary["Current year"] accumulate(add_ref_to_practice('y'+int(each)));
	}
	
	// build the histogram for a given indicator
	list<float> yearly_histo(string indicator){
		list<float> tmp;
		loop i from: 0 to: length(first(practices).year_summary["Current year"]){
			loop p over: practices{
				tmp <+ scale = "Total" ? p.year_summary[indicator][i] :  (p.year_summary[indicator][i] / p.year_summary["Crop area"][i]);
			}
		}
		return list<float>(truncate(tmp));
	}
	
	// function to build y label, based on the scale choice (total or per ha)
	string y_label{
		return scale = "Total" ? "Total " + current_chart : current_chart + " per ha";
	}
	
	// compute the color of the bars of the histogram
	list histo_colors {
		list<rgb> cl <- practices collect (each.color_farmer);
		return first(practices).year_summary["Current year"] accumulate(cl);
	}
	
	// defines the visilibity of charts
	bool visibility{
		return current_chart != "Adoption rate" and current_chart != "Expenses details";
	}
	
	// returns the adoption rate
	list<list<float>> get_adoption_rate {
		if (scale = "Total"){
			return practices collect(each.year_summary["Crop area"]);
		}else{
			float total_area <- Plot sum_of (each.shape.area);
			list<list<float>> l <- [];
			loop p over: practices {
				l <+ p.year_summary["Crop area"] collect (each/total_area*100);
			}
			return l;
		}
	}
	
	
	// keep information corresponding to the current time range (all, 1 year, 3 years)
	list truncate(list l){
		switch time_range_type{
			match "Last year" {
				int start_index <- length(l) - length(practices);
				return copy_between(l, start_index, length(l-1));
			}
			match "Last 3 years" {
				int start_index <- length(l) - 3 * length(practices);
				return  copy_between(l, start_index, length(l-1));
			}
			default {return l;}
		}	
	}
	
	
} 


// ======================================================================
// experiments
// ======================================================================


// virtual generic experiment with common charts. All experiments inherit for this one, so it is not necessary to rewrite common charts
experiment generic_exp type:gui virtual: true {
	
	category "Daily indicators" expanded: true color: rgb(243, 156, 18);
	parameter "Indicators family" var: current_indicator_family among: ["Economy", "Practices seasons", "Biomass"] category: "Daily indicators";
	
	category "Year evolution" expanded: true color: rgb(46, 204, 113);
	parameter "Chart" var: current_chart init: "Total crop biomass per practice" category: "Year evolution" among: chart_list;
	
	category "Weather and practices" expanded: true color: rgb(52, 152, 219);
	parameter "Show practice seasons" var: show_season category: "Weather and practices" among: possible_practices.keys+"None";
	
	category  "Scale and time" expanded: true color: rgb(100, 100, 100);
	parameter "Time range" var: time_range_type among: ["All","Last year","Last 3 years"] category: "Scale and time";
	parameter "Scale" var: scale init: "Total" category: "Scale and time" among: ["Total","Per ha"];
	
	output {
		display base_map axes: false toolbar: false virtual: true{
			species species(plot_species);  
			species Farmer;
		}
		
		display base_practices_information type: 2d toolbar: false antialias: true virtual: true{
//			overlay position: {0, 0} size: {2000, 32#px} background: #white transparency: 0 rounded: false{
//				draw string("Seasons") at: {10 #px,10 #px}  anchor: #top_left color: #black font:overlay_font ; 
//            }

			chart histogram_info name: "" type: histogram y_label: y_label() visible: visibility(){
				datalist yearly_histo_labels() value: yearly_histo(current_chart)  color: histo_colors() ;
			}
			
			chart "Adoption rate"  type: histogram  visible: current_chart = "Adoption rate" y_label: scale = "Total" ? "Area per practice":"Area (%)"{
				datalist practices collect(each.short_name) value:  get_adoption_rate() color: practices collect(each.color_farmer) style: stack;
			}


			chart "Expenses details"  type: histogram  visible: current_chart = "Expenses details" y_label: scale = "Total" ? "Expenses per practice":"Expenses per ha"{
				datalist expense_categories.keys value:   get_expenses_by_category() color: expense_categories.values style: stack;
//				datalist expense_categories.keys value:   [[4,5],[7,5],[1,2], [4,5]] color: expense_categories.values style: stack;
			}


		}
		
		display base_indicators type: 2d toolbar: false antialias: true virtual: true {
			
// overlay requires bug fix
//
//			overlay position: {0, 0} size: {0.1, 0.1} background: #white transparency: 1 rounded: false{
//				draw string("Daily indicators") at: {10 #px,10 #px}  anchor: #top_left color: #black font:overlay_font ; 
//          }

			
			// economy indicators
			
			chart "Income/expenses (total)" type: series size: {0.5,1} visible: current_indicator_family = "Economy" and scale = "Total" x_range: time_range(time_range_type) {
				loop p over: reverse(practices.values) {
					data "Total income of " + p.short_name value: p.day_income color: p.color_farmer style: bar;
					data "Total expenses of " + p.short_name value: - p.day_expenses color: p.color_farmer style: bar;
				}
			}
			
			chart "Income/expenses (per ha)" type: series size: {0.5,1} visible: current_indicator_family = "Economy" and scale = "Per ha" x_range: time_range(time_range_type)  {
				loop p over: reverse(practices.values) {
					data "Income of" + p.short_name + "Per ha" value: get_income_per_ha(p) color: p.color_farmer style: bar;
					data "Expenses of" + p.short_name + "Per ha" value: - get_expenses_per_ha(p) color: p.color_farmer style: bar;
				}
			}
			
			chart "Balance (total)" type: series size: {0.5,1}  position: {0.5,0.0} visible: current_indicator_family = "Economy" and scale = "Total" x_range: time_range(time_range_type) {
				loop p over: reverse(practices.values) {
					data "Balance " + p.short_name value: p.total_balance  color: p.color_farmer style: line marker: false accumulate_values: true;
				}
			}
			
			chart "Balance (per ha)" type: series size: {0.5,1}  position: {0.5,0.0} visible: current_indicator_family = "Economy" and scale = "Per ha" x_range: time_range(time_range_type) {
				loop p over: reverse(practices.values) {
					data "Balance " + p.short_name value: p.balance_per_ha  color: p.color_farmer style: line marker: false accumulate_values: true;
				}
			}
			
// should be simpler, but accumulate_values is not working ??
// fix, test, then remove unecessary variables in practice: total_balance and balance_per_ha
//
//			chart "Balance" type: series size: {0.5,1} visible: current_indicator_family = "Economy" and scale = "Total" x_range: time_range(time_range_type) {
//				loop p over: reverse(practices.values) {
//					data "Balance" + p.short_name value: p.day_income  color: p.color_farmer style: line marker: false accumulate_values: true;
//				}
//			}
			
			
			// season indicators
			
			chart SeasonsChart name: "Seasons" visible: current_indicator_family = "Practices seasons" type: series  lines: false y_range: [0, max(2.5,length(practices.values)+0.5)] y_tick_values_visible: false x_range: time_range(time_range_type)  {
				loop i from: 0 to: length(practices.values)-1 step: 1 {
					data ""+i value: (i+0.5) color: #white style: area line_visible: false marker: false;
					data practices.values[i].short_name+" seasons" value: (i+1)*int(practices.values[i].is_active_season) color: practices.values[i].color_farmer style: area line_visible: false marker: false;
				}
			}
			
			//	Biomass indicators	

			chart totalCropBiomass name: "Total crop biomass" visible: current_indicator_family = "Biomass" and scale = "Total" type: series x_range: time_range(time_range_type)  {
				loop i from: 0 to: length(practices.values)-1 step: 1 {
					data practices.values[i].short_name+" biomass" value: get_total_biomass(practices.values[i]) color: practices.values[i].color_farmer marker: false;
				}
			}
			
			chart CropBiomassPerHa name: "Crop biomass per ha" visible: current_indicator_family = "Biomass" and scale = "Per ha" type: series x_range: time_range(time_range_type)  {
				loop i from: 0 to: length(practices.values)-1 step: 1 {
					data practices.values[i].short_name+" biomass" value: get_biomass_per_ha(practices.values[i]) color: practices.values[i].color_farmer marker: false;
				}
			} 	
		}
		
		display base_weather type: 2d toolbar: false antialias: true virtual: true {
//			overlay position: {0, 0} size: {2000, 32#px} background: #white transparency: 0 rounded: false{
//				draw string("Weather") at: {10 #px,10 #px}  anchor: #top_left color: #black font:overlay_font ; 
//            }

			chart "Temperature" type: series size: {0.5,0.5} x_range: time_range(time_range_type) {
				data "temperature min" value: the_weather.temp_min[current_date]  color: rgb(49, 130, 189) marker: false style: spline;
				data "temperature max" value: the_weather.temp_max[current_date]  color: rgb(230, 85, 13) marker: false style: spline;
				// season overlay
				datalist current_practices() collect(each.short_name+" seasons") legend: current_practices() collect(each.short_name) value: current_practices() collect(each.activity) color: current_practices() collect rgb(each.color_farmer,season_opacity) style: area line_visible: false marker: false use_second_y_axis: true;
			}
			chart "Solar radiation" type: series size: {0.5,0.5} position: {0.5,0.0} x_range: time_range(time_range_type) {
				data "Solar radiation" value: the_weather.solar_radiation[current_date]  color: rgb(255, 191, 0) marker: false style: spline;
				// season overlay
				datalist current_practices() collect(each.short_name+" seasons") legend: current_practices() collect(each.short_name) value: current_practices() collect(each.activity) color: current_practices() collect rgb(each.color_farmer,season_opacity) style: area line_visible: false marker: false use_second_y_axis: true;
			}
			chart "Humidity" type: series size: {0.5,0.5} position: {0.0,0.5} x_range: time_range(time_range_type) {
				data "Humidity" value: the_weather.humidity[current_date]  color: rgb(102, 194, 255) marker: false style: spline ;
				// season overlay		
				datalist current_practices() collect(each.short_name+" seasons") legend: current_practices() collect(each.short_name) value: current_practices() collect(each.activity) color: current_practices() collect rgb(each.color_farmer,season_opacity) style: area line_visible: false marker: false use_second_y_axis: true;
			}
			chart "Rainfall" type: series size: {0.5,0.5} position: {0.5,0.5} x_range: time_range(time_range_type) {
				data "Rainfall" value: the_weather.rainfall[current_date]  color: rgb(33, 113, 181) style: bar;
				// season overlay
				datalist current_practices() collect(each.short_name+" seasons") legend: current_practices() collect(each.short_name) value: current_practices() collect(each.activity) color: current_practices() collect rgb(each.color_farmer,season_opacity) style: area line_visible: false marker: false use_second_y_axis: true;
			}
		}
		

	} 
}


// simple experiment
experiment "Simple experiment" type:gui parent: generic_exp {	
	
	output {
		layout value: horizontal([vertical([0::50,1::50])::50,vertical([2::50,3::50])::50]) tabs:false;
		
		display map axes: false toolbar: false parent: base_map{
		
//			agents pest value: (plot_species != Plot?species("Parasite"):nil);	
//			agents predator value: (plot_species != Plot?species("Predator"):nil);
		}

		
		display pc name: "Year evolution" type: 2d toolbar: false antialias: true parent: base_practices_information{}
		
		display Indicators type: 2d toolbar: false antialias: true parent: base_indicators{}
		
		display Weather type: 2d toolbar: false antialias: true parent: base_weather{}
		
	} 
}



