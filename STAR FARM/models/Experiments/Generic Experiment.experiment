/** 
* Name: GenericExperiment
* This wizard creates a new experiment file. 
* Author: roiarthurb
* Tags: 
*/

model AbstractStarFarm

//import "../Parameters.gaml"

import "../Global.gaml"   
global{ 
	
	//--------------VISUAL CONSTANTS AND PARAMETERS-----------------------//
	int overlay_font_size <- 12 const: true;
	font overlay_font <- font("SansSerif", overlay_font_size, #bold) const: true;
	int season_opacity <- 100 const: true;
	
	bool display_background <- false;
	image_file background_image_file <-display_background ?  image_file("../includes/Dong Thap/background.png") : image_file("../includes/Images/default_background.png");
	
	
	//--------------variable used for display-----------------------------//
	string current_indicator_family <- "Economy";
	string show_season <- first(possible_practices.keys) ;
	string time_range_type <- "All";
	string scale <- "Total";
	
	//--------------Map VISUALIZATION PARAMETERS--------------------------//
	point overlayPos <- {0.1, 0.1};
	font titleFont<-font("Helvetica", 12,#bold);
	rgb background_color<-#white;
	rgb text_color<-#black;
	bool show_overlay<-true;
	
	// List of the key indicators to be monitored
	// the next list should be initialized using key_indicators from Practices.gaml, but presently there is a bug with Gama	

	list<string> chart_list <- ["Harvest","Profit","Water consumption","Fertilizer consumption","Adoption rate","Expenses details"];
	list<string> indicator_families_list <- ["Economy", "Practices seasons", "Biomass","GHG"];
	string current_chart <- first(chart_list);
 
	
	
	// ======================================================================
	// indicators
	// ======================================================================
	
	////WARNING: (Arno) WRONG FORMULA fro now it is attached to a crop should be plot
	// computes the total biomass for a given type of crop and practice
	float get_total_ghg(Crop_practice p){
		return Crop where(each.the_farmer.practice = p) sum_of(each.B);
	}
	////WARNING: WRONG FORMULA
	// computes the biomass per ha for a given type of crop and practice
	float get_ghg_per_ha(Crop_practice p){
		return p.practice_area = 0 ? 0 : get_total_biomass(p) / p.practice_area;
	}
	
	// computes the total biomass for a given type of crop and practice. Convert to kg/ha

	float get_total_biomass(Crop_practice p){
		return (Crop where(each.the_farmer.practice = p) sum_of(each.B)) * 10;
	}
	
	// computes the biomass per ha for a given type of crop and practice
	float get_biomass_per_ha(Crop_practice p){
		return p.practice_area = 0 ? 0 : get_total_biomass(p) / p.practice_area;
	}
	
	// computes the income per ha for a given type of crop and practice
	float get_income_per_ha(Crop_practice p){
		return p.practice_area = 0 ? 0 : p.day_income / p.practice_area;
	}
	
	// computes the biomass per ha for a given type of crop and practice
	float get_expenses_per_ha(Crop_practice p){
		return p.practice_area = 0 ? 0 : p.day_expenses / p.practice_area;
	}
	// detail the expenses per categories
	list<list<float>> get_expenses_by_category{
		list<list<float>> res <- [];
		loop i from: 0 to: length(expense_categories.keys)-1{
			list<float> vals;
			int last_index <- length(first(practices.values).year_summary["Expense: "+expense_categories.keys[i]]) - 1;
			int first_index;
			
			switch time_range_type{ 
				
				match "Last year" {
					first_index <- last_index;
					
				}
				match "Last 3 years" {
					first_index <- last_index - 2;
				}
				match "Last 5 years" {
					first_index <- last_index - 4;
				}
				default {
					first_index <- 0;
				}
			}
			vals <- practices.values collect (sum(copy_between(each.year_summary["Expense: "+expense_categories.keys[i]],first_index,last_index))
						/ (scale = "Total" ? 1 : max(0.001,each.practice_area)));
			res <+ vals;
		}
		return res;

	}
		 
	// ======================================================================
	// auxiliary functions for charts
	// ======================================================================
	
	// compute the time range for charts, i.e. the number of days for which charts should be displayed
	int time_range(string s){
		int range <- max(1,cycle);
		switch s {
			match "Last year" {return min(365,range);}
			match "Last 3 years" {return min(1095,range);}
			match "Last 3 years" {return min(1825,range);}
			default {return range;}
		}
	}
	
	// make x labels for season histograms
	list<string> update_x_labels(Crop_practice p){
		list<string> tmp;
		ask first(practices){
			tmp <- create_x_labels(); 
		}		 
		return tmp collect(each+p.id);
	}
	
	// used to keep only practices that are currently displayed
	list<Crop_practice> current_practices{
		return practices.values where (each.id = show_season);
	}
		 
	// ======================================================================
	// functions to build yearly histograms
	// ======================================================================
	 
	// functions to build x labels for histograms
	list<string> add_ref_to_practice(string s){
		return practices collect (each.short_name+' '+s);
	}
	
	// generate the current histogram labels
	list<string> yearly_histo_labels{
		return first(practices).year_summary["Current year"] accumulate(add_ref_to_practice(string(int(each))));
	}
	
	// build the histogram for a given indicator
	list<float> yearly_histo(string indicator){
		// if the histogram is not visible, no need to compute the time series. The time series is replaced
		// by a list with the same number of 0 to avoid bugs in Gama.
		int data_length <- length(first(practices).year_summary["Current year"]);
		if (data_length = 0){
			return list<float>([]);
		}
		if (!visibility()){
			return list_with(length(practices) * data_length, 0.0);
		}

		list<float> tmp;
		int last_index <- data_length - 1;
//		write ""+indicator+" "+ first(practices).year_summary collect (length(each));
		loop i from: 0 to: last_index{
			loop p over: practices{
				tmp <+ scale = "Total" ? p.year_summary[indicator][i] :  (p.year_summary[indicator][i] / p.year_summary["Crop area"][i]);
			}
		}
		return list<float>(truncate(tmp));
	}
	
	// function to build y label, based on the scale choice (total or per ha)
	string y_label{
		return scale = "Total" ? "Total " + current_chart : current_chart + " per ha";
	}
	
	// compute the color of the bars of the histogram. Get the color list of practices, and duplicates
	// for each year that is displayed
	list histo_colors {
		list<rgb> cl <- practices collect (each.color);
		return first(practices).year_summary["Current year"] accumulate(cl);
	}
	
	// defines the visilibity of charts
	bool visibility{
		return current_chart != "Adoption rate" and current_chart != "Expenses details";
	}
	
	// returns the adoption rate
	list<list<float>> get_adoption_rate {
		// if the scale is the total adoption rate, display the surface for each practice
		if (scale = "Total"){
			return practices collect(each.year_summary["Crop area"]);
		}
		// otherwise display the adoption rate as a percentage
		float total_area <- Plot sum_of (each.surface_in_ha); 
		list<list<float>> l <- [];
		loop p over: practices {
			l <+ p.year_summary["Crop area"] collect (each/total_area*100);
		}
		return l;
	}
	
	
	// keep information corresponding to the current time range (all, 1 year, 3 years)
	list truncate(list l){
		switch time_range_type{
			match "Last year" {
				int start_index <- length(l) - length(practices);
				return copy_between(l, start_index, length(l-1));
			}
			match "Last 3 years" {
				int start_index <- length(l) - 3 * length(practices);
				return  copy_between(l, start_index, length(l-1));
			}
			default {return l;}
		}	
	}
}

// virtual generic experiment with common charts. All experiments inherit for this one, so it is not necessary to rewrite common charts
experiment generic_exp type:gui virtual: true {
	
	category "Daily indicators" expanded: true color: category_color["Daily indicators"];
	parameter "Indicators family" var: current_indicator_family among: indicator_families_list category: "Daily indicators";	
	
	category "Year evolution" expanded: true color: category_color["Year evolution"];
	parameter "Chart" var: current_chart init: "Total crop biomass per practice" category: "Year evolution" among: chart_list;

	
	category  "Scale and time" expanded: true color: category_color["Scale and time"];
	parameter "Time range" var: time_range_type among: ["All", "Last year", "Last 3 years", "Last 5 years"] category: "Scale and time";
	parameter "Scale" var: scale init: "Total" category: "Scale and time" among: ["Total","Per ha"];
	parameter "Show practice seasons" var: show_season category: "Scale and time" among: possible_practices.keys+"None";
	 
	output {
		layout value: horizontal([vertical([0::50,1::50])::50,vertical([2::50,3::50])::50]) tabs:false;
		
		display base_map axes: false toolbar: false virtual: true{
			overlay position:overlayPos size: {0.1, 0.1} background: background_color transparency: 0.0 border: background_color rounded:true visible:show_overlay{			 
			  point legendPos <- overlayPos + {10#px, 10#px};
			  float spaceY <- 25#px;
			  string day_str <- (current_date.day < 10 ? "0" + current_date.day : "" + current_date.day);
			  string month_str <- (current_date.month < 10 ? "0" + current_date.month : "" + current_date.month);
			  string date_str<-day_str + "/" + month_str + "/"   + string(current_date.year);
			  draw string("STAR FARM: " + date_str) at: legendPos color: text_color font: titleFont;	
			  legendPos <- {legendPos.x, legendPos.y + spaceY};
			  draw string("Nb Famers: " + length(Farmer)) at: legendPos color: text_color font: titleFont;	
			  legendPos <- {legendPos.x, legendPos.y + spaceY};
			  loop p over: practices_color.keys {
				draw square(10 #px) at: legendPos color: practices_color[p] border: #white;
				draw p + ": "+ length(Farmer where (each.practice.short_name = p)) at: legendPos + {20 #px, 5 #px} color: practices_color[p]  font:titleFont;
				legendPos <- {legendPos.x, legendPos.y + spaceY/2};
			  }			
			}
			image background_image_file refresh: false visible: display_background;
			species species(plot_species);  
			species Farmer;    
		} 
		display base_practices_information type: 2d toolbar: false antialias: true virtual: true{
//			overlay position: {0, 0} size: {2000, 32#px} background: #white transparency: 0 rounded: false{
//				draw string("Seasons") at: {10 #px,10 #px}  anchor: #top_left color: #black font:overlay_font ; 
//            }

			chart histogram_info name: "" type: histogram y_label: y_label() visible: visibility() {
				datalist yearly_histo_labels() value: yearly_histo(current_chart)  color: histo_colors();
			}
			
			chart "Adoption rate"  type: histogram  visible: current_chart = "Adoption rate" y_label: scale = "Total" ? "Area per practice":"Area (%)"{
				datalist practices collect(each.short_name) value:  get_adoption_rate() color: practices collect(each.color) style: stack;
			}

			chart "Expenses details"  type: histogram  visible: current_chart = "Expenses details" y_label: scale = "Total" ? "Expenses per practice":"Expenses per ha"{
				datalist expense_categories.keys value:   get_expenses_by_category() color: expense_categories.values style: stack;
//				datalist expense_categories.keys value:   [[4,5],[7,5],[1,2], [4,5]] color: expense_categories.values style: stack;
			}


		} 
		
		display base_daily_indicators type: 2d toolbar: false antialias: true virtual: true {
			
// overlay requires bug fix
//
//			overlay position: {0, 0} size: {0.1, 0.1} background: #white transparency: 1 rounded: false{
//				draw string("Daily indicators") at: {10 #px,10 #px}  anchor: #top_left color: #black font:overlay_font ; 
//          }

			// economy indicators
			
			chart "Income/expenses (total)" type: series size: {0.5,1} visible: current_indicator_family = "Economy" and scale = "Total" x_range: time_range(time_range_type){
				loop p over: reverse(practices.values) {
					data "Total income of " + p.short_name value: p.day_income color: p.color style: bar;
					data "Total expenses of " + p.short_name value: - p.day_expenses color: p.color style: bar;
				}
			}
			
			chart "Income/expenses (per ha)" type: series size: {0.5,1} visible: current_indicator_family = "Economy" and scale = "Per ha" x_range: time_range(time_range_type)  {
				loop p over: reverse(practices.values) {
					data "Income of " + p.short_name + " per ha" value: get_income_per_ha(p) color: p.color style: bar;
					data "Expenses of " + p.short_name + " per ha" value: - get_expenses_per_ha(p) color: p.color style: bar;
				}
			}
			
			chart "Balance (total)" type: series size: {0.5,1}  position: {0.5,0.0} visible: current_indicator_family = "Economy" and scale = "Total" x_range: time_range(time_range_type){
				loop p over: reverse(practices.values) {
					data "Balance " + p.short_name value: p.total_balance  color: p.color style: line marker: false accumulate_values: true;
				}
			}
			
			chart "Balance (per ha)" type: series size: {0.5,1}  position: {0.5,0.0} visible: current_indicator_family = "Economy" and scale = "Per ha" x_range: time_range(time_range_type) {
				loop p over: reverse(practices.values) {
					data "Balance " + p.short_name value: p.balance_per_ha  color: p.color style: line marker: false accumulate_values: true;
				}
			}
			
// should be simpler, but accumulate_values is not working ??
// fix, test, then remove unecessary variables in practice: total_balance and balance_per_ha
//
//			chart "Balance" type: series size: {0.5,1} visible: current_indicator_family = "Economy" and scale = "Total" x_range: time_range(time_range_type) {
//				loop p over: reverse(practices.values) {
//					data "Balance" + p.short_name value: p.day_income  color: p.color_farmer style: line marker: false accumulate_values: true;
//				}
//			}
			
			
			// season indicators
			
			chart SeasonsChart name: "Seasons" visible: current_indicator_family = "Practices seasons" type: series  lines: false y_range: [0, max(2.5,length(practices.values)+0.5)] y_tick_values_visible: false x_range: time_range(time_range_type)  {
				loop i from: 0 to: length(practices.values)-1 step: 1 {
					data ""+i value: (i+0.5) color: #white style: area line_visible: false marker: false;
					data practices.values[i].short_name+" seasons" value: (i+1)*int(practices.values[i].is_active_season) color: practices.values[i].color style: area line_visible: false marker: false;
				}
			}
			
			//	Biomass indicators	

			chart totalCropBiomass name: "Total crop biomass" visible: current_indicator_family = "Biomass" and scale = "Total" type: series x_range: time_range(time_range_type)  {
				loop i from: 0 to: length(practices.values)-1 step: 1 {
					data practices.values[i].short_name+" biomass" value: get_total_biomass(practices.values[i]) color: practices.values[i].color marker: false;
				}
			}
			
			chart CropBiomassPerHa name: "Crop biomass per ha" visible: current_indicator_family = "Biomass" and scale = "Per ha" type: series x_range: time_range(time_range_type)  {
				loop i from: 0 to: length(practices.values)-1 step: 1 {
					data practices.values[i].short_name+" biomass" value: get_biomass_per_ha(practices.values[i]) color: practices.values[i].color marker: false;
				}
			} 	
			
			
			//	GHG indicators	

			chart totalCropGHG name: "Total crop GHG" visible: current_indicator_family = "GHG" and scale = "Total" type: series x_range: time_range(time_range_type)  {
				loop i from: 0 to: length(practices.values)-1 step: 1 {
					data practices.values[i].short_name+" ghg" value: get_total_ghg(practices.values[i]) color: practices.values[i].color marker: false;
				}
			}
			
			chart CropGHGPerHa name: "Crop biomass per ha" visible: current_indicator_family = "Biomass" and scale = "Per ha" type: series x_range: time_range(time_range_type)  {
				loop i from: 0 to: length(practices.values)-1 step: 1 {
					data practices.values[i].short_name+" ghg" value: get_ghg_per_ha(practices.values[i]) color: practices.values[i].color marker: false;
				}
			}
		}
		
		display base_weather type: 2d toolbar: false antialias: true virtual: true {
//			overlay position: {0, 0} size: {2000, 32#px} background: #white transparency: 0 rounded: false{
//				draw string("Weather") at: {10 #px,10 #px}  anchor: #top_left color: #black font:overlay_font ; 
//            }

			chart "Temperature" type: series size: {0.5,0.5} x_range: time_range(time_range_type) {
				data "temperature min" value: the_weather.t_min  color: rgb(49, 130, 189) marker: false style: spline;
				data "temperature max" value: the_weather.t_max color: rgb(230, 85, 13) marker: false style: spline; 
				// season overlay
				datalist current_practices() collect(each.short_name+" seasons") legend: current_practices() collect(each.short_name) value: current_practices() collect(each.activity) color: current_practices() collect rgb(each.color,season_opacity) style: area line_visible: false marker: false use_second_y_axis: true;
			}
			chart "Solar radiation" type: series size: {0.5,0.5} position: {0.5,0.0} x_range: time_range(time_range_type) {
				data "Solar radiation" value: the_weather.solar_rad color: rgb(255, 191, 0) marker: false style: spline;
				// season overlay
				datalist current_practices() collect(each.short_name+" seasons") legend: current_practices() collect(each.short_name) value: current_practices() collect(each.activity) color: current_practices() collect rgb(each.color,season_opacity) style: area line_visible: false marker: false use_second_y_axis: true;
			}
			chart "Humidity" type: series size: {0.5,0.5} position: {0.0,0.5} x_range: time_range(time_range_type) {
				data "Humidity" value: the_weather.humidity  color: rgb(102, 194, 255) marker: false style: spline ;
				// season overlay		
				datalist current_practices() collect(each.short_name+" seasons") legend: current_practices() collect(each.short_name) value: current_practices() collect(each.activity) color: current_practices() collect rgb(each.color,season_opacity) style: area line_visible: false marker: false use_second_y_axis: true;
			}
			chart "Rainfall" type: series size: {0.5,0.5} position: {0.5,0.5} x_range: time_range(time_range_type) {
				data "Rainfall" value: the_weather.rain  color: rgb(33, 113, 181) style: bar;
				// season overlay
				datalist current_practices() collect(each.short_name+" seasons") legend: current_practices() collect(each.short_name) value: current_practices() collect(each.activity) color: current_practices() collect rgb(each.color,season_opacity) style: area line_visible: false marker: false use_second_y_axis: true;
			}
		}
		

	} 
}